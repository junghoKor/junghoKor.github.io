<!DOCTYPE html> <html lang="ko"> <head> <meta charset="UTF-8" /> <title>RANSAC</title> <style> body { margin: 0; background-color: black; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; color: white; font-family: sans-serif; } canvas { background-color: black; border: 1px solid #444; } .controls { margin-top: 20px; display: flex; gap: 10px; flex-wrap: wrap; justify-content: center; } button { padding: 8px 16px; font-size: 16px; cursor: pointer; } input { width: 60px; padding: 6px; font-size: 14px; text-align: center; } label { font-size: 14px; } .status { margin-top: 10px; font-size: 16px; color: lightgreen; } </style> </head> <body> <h1 style="color: white; text-align: center; margin-bottom: 10px; font-family: sans-serif;">2차함수 RANSAC 시뮬레이션</h1> <canvas id="canvas" width="800" height="600"></canvas> <div class="controls"> <button id="runHalley">Halley방식</button> <button id="runEllipse">타원근사</button> <button id="runYDistance">단순Y값</button> <button id="runFastParabola">fast_parabola_distance</button> <button id="regenerate">랜덤생성</button> <label>반복횟수: <input type="number" id="iterations" value="1000" min="10" max="10000" /></label> <label>Inlier거리: <input type="number" id="threshold" value="4" min="1" max="100" /></label> </div> <div class="status" id="inlierCount">Inliers: 0</div> <div class="status" id="elapsedTime">판별시간: 0 ms</div> <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.min.js"></script> <script> const canvas = document.getElementById('canvas'); const ctx = canvas.getContext('2d'); const runHalleyBtn = document.getElementById('runHalley'); const runEllipseBtn = document.getElementById('runEllipse'); const runYDistanceBtn = document.getElementById('runYDistance'); const runFastParabolaBtn = document.getElementById('runFastParabola'); const regenerateBtn = document.getElementById('regenerate'); const iterationsInput = document.getElementById('iterations'); const thresholdInput = document.getElementById('threshold'); const inlierDisplay = document.getElementById('inlierCount'); const timeDisplay = document.getElementById('elapsedTime');

let points = [];
let inlierPoints = [];
let trueFunc = () => 0;

function generatePoints() {
  points = [];
  const canvasWidth = canvas.width;
  const canvasHeight = canvas.height;

  // 랜덤 2차 함수 계수 생성 (a는 0.0005~0.002, b는 -1~1, c는 100~400)
  const a = 0.0005 + Math.random() * 0.0015;
  const b = -1 + Math.random() * 2;
  const c = 100 + Math.random() * 300;

  // 정답 곡선 점 100개 생성 (점 수 감소)
  for (let i = 0; i < 100; i++) {
    const x = (i / 99) * canvasWidth;
    const y = a * x * x + b * x + c;
    if (y > 1 && y < canvasHeight) {
      points.push({ x, y, isTrue: true });
    }
  }

  // 정답 곡선 주변 노이즈 점 400개 생성 (노이즈 점 수 증가)
  for (let i = 0; i < 400; i++) {
    const baseX = Math.random() * canvasWidth;
    const baseY = a * baseX * baseX + b * baseX + c;
    const noiseX = baseX + (Math.random() * 40 - 20);
    const noiseY = baseY + (Math.random() * 60 - 30);
    if (noiseX >= 0 && noiseX <= canvasWidth && noiseY > 1 && noiseY < canvasHeight) {
      points.push({ x: noiseX, y: noiseY, isTrue: false });
    }
  }

  // 캔버스 전체에 노이즈 점 300개 생성 (y>1 필터링)
  for (let i = 0; i < 300; i++) {
    const x = Math.random() * canvasWidth;
    const y = Math.random() * (canvasHeight - 1) + 1;
    points.push({ x, y, isTrue: false });
  }

  // trueFunc 함수 업데이트 (정답 2차 함수)
  trueFunc = (x) => a * x * x + b * x + c;

  drawPoints();
}

function drawPoints() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  for (const p of points) {
    ctx.fillStyle = 'white';
    ctx.fillRect(p.x, p.y, 2, 2);
  }
  for (const p of inlierPoints) {
    ctx.fillStyle = 'lime';
    ctx.fillRect(p.x, p.y, 3, 3);
  }
}

function fitQuadratic(p1, p2, p3) {
  const X = [p1.x, p2.x, p3.x];
  const Y = [p1.y, p2.y, p3.y];
  const A = [
    [X[0] * X[0], X[0], 1],
    [X[1] * X[1], X[1], 1],
    [X[2] * X[2], X[2], 1],
  ];
  const inv = math.inv(A);
  return math.multiply(inv, Y);
}

function calcErrorHalley(coeffs, point) {
  const [a, b, c] = coeffs;
  const { x: x0, y: y0 } = point;

  function dF(x) {
    const fx = a * x * x + b * x + c;
    const dfx = 2 * a * x + b;
    return 2 * (x - x0) + 2 * (fx - y0) * dfx;
  }

  function ddF(x) {
    const fx = a * x * x + b * x + c;
    const dfx = 2 * a * x + b;
    const ddfx = 2 * a;
    return 2 + 2 * (dfx ** 2 + (fx - y0) * ddfx);
  }

  function dddF(x) {
    const dfx = 2 * a * x + b;
    const ddfx = 2 * a;
    return 4 * a * dfx + 2 * ddfx * ddfx;
  }

  let x = x0;
  for (let i = 0; i < 10; i++) {
    const f1 = dF(x);
    const f2 = ddF(x);
    const f3 = dddF(x);
    const denom = f2 - (f1 * f3) / (2 * f2);
    if (Math.abs(denom) < 1e-6) break;
    const delta = f1 / denom;
    x = x - delta;
    if (Math.abs(delta) < 1e-6) break;
  }

  const fx = a * x * x + b * x + c;
  return Math.hypot(x - x0, fx - y0);
}

function calcErrorEllipse(coeffs, point) {
  const [a, b, c] = coeffs;
  const fx = a * point.x * point.x + b * point.x + c;
  const dy = fx - point.y;
  return Math.sqrt(dy * dy * 0.5);
}

function calcErrorYDistance(coeffs, point) {
  const [a, b, c] = coeffs;
  const fy = a * point.x * point.x + b * point.x + c;
  return Math.abs(fy - point.y);
}

// fast_parabola_distance 계산 함수 (게임에서 주로 쓰이는 방식, 수직 거리 + 기울기 보정 근사, 속도 개선 버전)
function calcErrorFastParabola(coeffs, point) {
  const [a, b, c] = coeffs;
  const x = point.x;
  const y = point.y;
  const yParabola = a * x * x + b * x + c;
  const dy = Math.abs(yParabola - y);
  if (dy < 0.0001) return 0;
  const slope = 2 * a * x + b;
  const correction = dy * Math.abs(slope) / (1 + Math.abs(slope));
  return dy + correction;
}

function ransac(iter, threshold, errorFunc) {
  let bestModel = null;
  let bestInliers = [];

  for (let i = 0; i < iter; i++) {
    const sample = [];
    while (sample.length < 3) {
      const rand = points[Math.floor(Math.random() * points.length)];
      if (!sample.includes(rand)) sample.push(rand);
    }

    const model = fitQuadratic(...sample);
    const inliers = points.filter(p => errorFunc(model, p) < threshold);

    if (inliers.length > bestInliers.length) {
      bestModel = model;
      bestInliers = inliers;
    }
  }

  return { model: bestModel, inliers: bestInliers };
}

function drawCurve(coeffs, color = 'red') {
  ctx.beginPath();
  ctx.strokeStyle = color;
  ctx.lineWidth = 2;
  for (let x = 0; x <= canvas.width; x++) {
    const y = coeffs[0] * x * x + coeffs[1] * x + coeffs[2];
    if (x === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  }
  ctx.stroke();
}

function runRANSAC(errorFunc) {
  const iter = parseInt(iterationsInput.value) || 200;
  const threshold = parseFloat(thresholdInput.value) || 30;

  const start = performance.now();
  const { model, inliers } = ransac(iter, threshold, errorFunc);
  const end = performance.now();

  inlierPoints = inliers;
  drawPoints();
  drawCurve(model, 'red');

  inlierDisplay.textContent = `Inliers: ${inliers.length}`;
  timeDisplay.textContent = `판별시간: ${Math.round(end - start)} ms`;
}

runHalleyBtn.addEventListener('click', () => runRANSAC(calcErrorHalley));
runEllipseBtn.addEventListener('click', () => runRANSAC(calcErrorEllipse));
runYDistanceBtn.addEventListener('click', () => runRANSAC(calcErrorYDistance));
runFastParabolaBtn.addEventListener('click', () => runRANSAC(calcErrorFastParabola));

regenerateBtn.addEventListener('click', () => {
  inlierPoints = [];
  generatePoints();
  inlierDisplay.textContent = 'Inliers: 0';
  timeDisplay.textContent = '판별시간: 0 ms';
});

generatePoints();

</script> </body> </html>
